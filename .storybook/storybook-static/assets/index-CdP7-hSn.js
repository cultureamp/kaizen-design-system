import{r as n,R as l}from"./index-CTjT7uj6.js";import{R as D}from"./index-9r8iugjR.js";import{c as q}from"./index-CCQ3W5xA.js";import{u as V}from"./usePopper-D4ykrdaR.js";function B(e,t,r){var v=this,a=n.useRef(null),o=n.useRef(0),i=n.useRef(null),p=n.useRef([]),m=n.useRef(),u=n.useRef(),f=n.useRef(e),y=n.useRef(!0);f.current=e;var w=typeof window<"u",g=!t&&t!==0&&w;if(typeof e!="function")throw new TypeError("Expected a function");t=+t||0;var T=!!(r=r||{}).leading,b=!("trailing"in r)||!!r.trailing,_="maxWait"in r,I="debounceOnServer"in r&&!!r.debounceOnServer,h=_?Math.max(+r.maxWait||0,t):null;n.useEffect(function(){return y.current=!0,function(){y.current=!1}},[]);var R=n.useMemo(function(){var A=function(s){var c=p.current,E=m.current;return p.current=m.current=null,o.current=s,u.current=f.current.apply(E,c)},k=function(s,c){g&&cancelAnimationFrame(i.current),i.current=g?requestAnimationFrame(s):setTimeout(s,c)},O=function(s){if(!y.current)return!1;var c=s-a.current;return!a.current||c>=t||c<0||_&&s-o.current>=h},S=function(s){return i.current=null,b&&p.current?A(s):(p.current=m.current=null,u.current)},N=function s(){var c=Date.now();if(O(c))return S(c);if(y.current){var E=t-(c-a.current),P=_?Math.min(E,h-(c-o.current)):E;k(s,P)}},x=function(){if(w||I){var s=Date.now(),c=O(s);if(p.current=[].slice.call(arguments),m.current=v,a.current=s,c){if(!i.current&&y.current)return o.current=a.current,k(N,t),T?A(a.current):u.current;if(_)return k(N,t),A(a.current)}return i.current||k(N,t),u.current}};return x.cancel=function(){i.current&&(g?cancelAnimationFrame(i.current):clearTimeout(i.current)),o.current=0,p.current=a.current=m.current=i.current=null},x.isPending=function(){return!!i.current},x.flush=function(){return i.current?S(Date.now()):u.current},x},[T,_,t,h,b,g,w,I]);return R}const U=400,C=l.createContext({isVisible:!1,isAnimIn:!1,isAnimOut:!1}),M=({isVisible:e,animationDuration:t=U,...r})=>{const[v,a]=n.useState(!1),[o,i]=n.useState(!1),[p,m]=n.useState(!1),u=B(()=>{i(!1)},t,{leading:!1}),f=B(()=>{a(!1)},0,{leading:!1});return e!==p&&(m(e),e?(u.cancel(),a(!0),f()):(f.cancel(),i(!0),u())),l.createElement(C.Provider,{value:{isVisible:e,isAnimOut:o,isAnimIn:v},...r})},W=()=>{const e=l.useContext(C);if(!e)throw new Error("useAnimation must be used within a AnimationProvider");return e};M.__docgenInfo={description:`Simply applies a css animation to transition a component in and out.
When the component is no longer needed, it will no longer be rendered to the
dom.`,methods:[],displayName:"AnimationProvider",props:{isAnimIn:{required:!1,tsType:{name:"boolean"},description:""},isAnimOut:{required:!1,tsType:{name:"boolean"},description:""},prevIsOpen:{required:!1,tsType:{name:"boolean"},description:""},animationDuration:{required:!1,tsType:{name:"number"},description:"",defaultValue:{value:"400",computed:!1}},isVisible:{required:!0,tsType:{name:"boolean"},description:""},children:{required:!1,tsType:{name:"ReactReactNode",raw:"React.ReactNode"},description:""}}};const H=["Button","IconButton","FilterButtonBase"];function L(e){return e.displayName||e.name||"Unknown"}const $=e=>{if(!l.isValidElement(e))return!1;const{props:t,type:r}=e;if("role"in t)return t.role!=="presentation"&&t.role!=="none";if(typeof r!="string"){const v=L(r);return H.includes(v)}return!(r==="div"||r==="span")},j="_tooltip_gruko_6",z="_tooltipContent_gruko_12",G="_informative_gruko_31",J="_positive_gruko_35",K="_cautionary_gruko_39",Q="_highlight_gruko_43",X="_arrow_gruko_48",Y="_arrowInner_gruko_58",Z="_arrowMain_gruko_74",ee="_arrowShadow_gruko_118",te="_displayInline_gruko_128",ne="_displayBlock_gruko_132",re="_displayInlineBlock_gruko_136",ie="_displayFlex_gruko_140",oe="_displayInlineFlex_gruko_144",d={tooltip:j,tooltipContent:z,default:"_default_gruko_27",informative:G,positive:J,cautionary:K,highlight:Q,arrow:X,arrowInner:Y,arrowMain:Z,arrowShadow:ee,displayInline:te,displayBlock:ne,displayInlineBlock:re,displayFlex:ie,displayInlineFlex:oe},ae=new Map([["above","top"],["below","bottom"],["left","left"],["right","right"]]),le=7,se=14,ue=({position:e,text:t,referenceElement:r,tooltipId:v,mood:a="default"})=>{const[o,i]=n.useState(null),[p,m]=n.useState(null),{styles:u,attributes:f}=V(r,o,{modifiers:[{name:"arrow",options:{element:p,padding:se/2+10}},{name:"offset",options:{offset:[0,le+6]}},{name:"preventOverflow",options:{padding:8,altAxis:!0,altBoundary:!0,tetherOffset:50}},{name:"flip",options:{padding:8,altBoundary:!0,fallbackPlacements:["left","top","bottom","right"]}}],placement:e?ae.get(e):void 0}),{isVisible:y,isAnimIn:w,isAnimOut:g}=W();return y||g||w?l.createElement("div",{ref:i,className:d.tooltip,style:u.popper,...f.popper,role:"tooltip",id:v},l.createElement("div",{className:q(d.tooltipContent,d[a])},t),l.createElement("div",{ref:m,className:d.arrow,style:u.arrow},l.createElement("div",{className:d.arrowInner},l.createElement("div",{className:q(d.arrowMain,d[a])}),l.createElement("div",{className:d.arrowShadow})))):null},ce=(e,t,r)=>$(e)?n.cloneElement(e,{"aria-describedby":r?t:void 0}):(console.warn("<Tooltip /> is not directly wrapping a semantic element, screen reader users will not be able to access the tooltip info. To ensure accessibility, Tooltip should be wrapping a semantic and focusable element directly."),e),F=({children:e,text:t,display:r="block",position:v="above",classNameOverride:a,portalSelector:o,animationDuration:i,isInitiallyVisible:p=!1,mood:m="default"})=>{const[u,f]=n.useState(p),[y,w]=n.useState(!1),[g,T]=n.useState(null),b=n.useId(),_=u||y,I=l.createElement(ue,{text:t,position:v,referenceElement:g,tooltipId:b,mood:m}),h=n.useRef(null);n.useEffect(()=>{h.current=o?document.querySelector(o):null},[o]),n.useEffect(()=>{o&&!h.current&&console.warn("The portal could not be created using the selector: "+o)},[h,o]);const R=()=>{switch(r){case"inline":return d.displayInline;case"block":return d.displayBlock;case"inline-block":return d.displayInlineBlock;case"flex":return d.displayFlex;case"inline-flex":return d.displayInlineFlex;default:return}};return l.createElement(M,{isVisible:_,animationDuration:i},l.createElement(l.Fragment,null,l.createElement("div",{ref:T,className:q(a,R()),onMouseEnter:()=>f(!0),onMouseLeave:()=>f(!1),onFocusCapture:()=>w(!0),onBlurCapture:()=>w(!1)},ce(e,b,_)),o&&h.current?D.createPortal(I,h.current):I))};F.displayName="Tooltip";F.__docgenInfo={description:"",methods:[],displayName:"Tooltip",props:{display:{required:!1,tsType:{name:"union",raw:'"block" | "inline" | "inline-block" | "flex" | "inline-flex"',elements:[{name:"literal",value:'"block"'},{name:"literal",value:'"inline"'},{name:"literal",value:'"inline-block"'},{name:"literal",value:'"flex"'},{name:"literal",value:'"inline-flex"'}]},description:`Unfortunately, the content needed to be wrapped in a div. This can sometimes
break the css layout. To get around this, we allow you to specify the css
display value directly. If you need to need to modify more values, feel free
to use the \`classNameOverride\` prop, but avoid it if you can.`,defaultValue:{value:'"block"',computed:!1}},position:{required:!1,tsType:{name:"union",raw:'"above" | "below" | "left" | "right"',elements:[{name:"literal",value:'"above"'},{name:"literal",value:'"below"'},{name:"literal",value:'"left"'},{name:"literal",value:'"right"'}]},description:`This is more a "desired position". The tooltip will automatically change
its position, if there's not enough room to show it in the one specified.`,defaultValue:{value:'"above"',computed:!1}},text:{required:!0,tsType:{name:"ReactReactNode",raw:"React.ReactNode"},description:"The text content for the tooltip"},children:{required:!1,tsType:{name:"ReactReactNode",raw:"React.ReactNode"},description:"This is the interactable element that is being described by the tooltip `text`"},classNameOverride:{required:!1,tsType:{name:"string"},description:""},mood:{required:!1,tsType:{name:"union",raw:'"default" | "informative" | "positive" | "cautionary" | "highlight"',elements:[{name:"literal",value:'"default"'},{name:"literal",value:'"informative"'},{name:"literal",value:'"positive"'},{name:"literal",value:'"cautionary"'},{name:"literal",value:'"highlight"'}]},description:"",defaultValue:{value:'"default"',computed:!1}},portalSelector:{required:!1,tsType:{name:"string"},description:"Render the tooltip inside a react portal, given the ccs selector.\nThis is typically used for instances where the menu is a descendant of an\n`overflow: scroll` or `overflow: hidden` element."},isInitiallyVisible:{required:!1,tsType:{name:"boolean"},description:`Should the tooltip be visible on the first render. Useful for visual
regression testing.`,defaultValue:{value:"false",computed:!1}},animationDuration:{required:!1,tsType:{name:"number"},description:""}}};const ve=F;export{ve as T,F as a};
