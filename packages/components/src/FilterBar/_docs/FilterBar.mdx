import { ArgTypes, Meta } from "@storybook/blocks"
import { ResourceLinks, KaioNotification, Installation, NoClipCanvas } from "../../../../../storybook/components"
import { LinkTo } from "../../../../../storybook/components/LinkTo"
import * as FilterBarStories from "./FilterBar.stories"

<Meta of={FilterBarStories} />

# Filter Bar

<ResourceLinks
  sourceCode="https://github.com/cultureamp/kaizen-design-system/tree/main/packages/components/src/FilterBar"
  className="!mb-8"
/>

<KaioNotification />

<Installation
  installCommand="yarn add @kaizen/components"
  importStatement='import { FilterBar } from "@kaizen/components"'
/>

## Overview

The Filter Bar is a collection of Filter components, used to filter data.

The `Clear all` button clears all active values, and moves any removable filters into the `Add Filters` menu.

This example showcases a minimal implementation of the FilterBar.

<NoClipCanvas of={FilterBarStories.BasicImplementation} />

## API

<ArgTypes of={FilterBarStories.BasicImplementation} />

### `FilterBar<ValuesMap>` (generic)

FilterBar accepts a TypeScript generic where you can outline the shape of the expected value types for each filter.

We also provide a `Filters` type which can accept the same generic to provide improved type safety.

`ValuesMap` should be in the shape of `{ [filterId]: filterValueType }`.

```tsx
import { FilterBar, Filters } from "@kaizen/components"

type ValuesMap = {
  filterId1: string
  filterId2: number
}

const [values, setValues] = useState<Partial<ValuesMap>>({
  filterId1: "default-value"
})

const filters = [
  { id: "filterId1", ...rest },
  { id: "filterId2", ...rest },
] satisfies Filters<ValuesMap>

return (
  <FilterBar<ValuesMap>
    filters={filters}
    values={values}
    onValuesChange={setValues}
  />
)
```

### `filters`

The `filters` prop is an array of attributes used to create the list of filters.

#### Usage

We also provide a `Filters<ValuesMap>` type you can use for improved type safety.

```tsx
import { FilterBar, Filters, DateRange, FilterMultiSelect } from "@kaizen/components"

type ValuesMap = {
  filterId1: string
  filterId2: string[]
  filterId3: DateRange
}

const filters = [
  {
    id: "filterId1",
    name: "Filter 1",
    Component: <FilterBar.Select {...props} />,
  },
  {
    id: "filterId2",
    name: "Filter 2",
    Component: (
      <FilterBar.MultiSelect {...props}>
        {/* Compose your structure using subcomponents of FilterMultiSelect */}
        {() => <FilterMultiSelect.ListBox {...props} />}
      </FilterBar.MultiSelect>
    ),
  },
  {
    id: "filterId3",
    name: "Filter 3",
    Component: <FilterBar.DateRangePicker {...props} />,
    isRemovable: true,
  },
] satisfies Filters<ValuesMap>
```

#### Filter attributes

Each filter has the following attributes:

- [`id: string`](#id-string)
- [`name: string`](#name-string)
- [`Component: JSX.Element`](#component-jsxelement)
- [`isRemovable?: boolean`](#isremovable-boolean)
- [`isUsableWhen?: (state: FiltersState<ValuesMap>) => boolean`](#isusablewhen-state-filtersstatevaluesmap--boolean)

##### `id: string`

A unique id for the filter.

##### `name: string`

The name used to label the filter, shown in the trigger button.

##### `Component: JSX.Element`

This attribute must be a Filter component or a custom component consuming the FilterBarContext.

Provided Filter components are built on top of their base component, and have the
`id`, `label`, `renderTrigger`, `isOpen`, `setIsOpen`, and `value` (or similar) props omitted as they are filled in for you.

If the component comes with an `onChange` (or similar) prop, it will be made optional and it can be used for additional actions (eg. adding analytics).

Available Filter components:
- `<FilterBar.DatePicker>` - extends <LinkTo pageId="components-filter-date-picker">FilterDatePicker</LinkTo>
  - `selectedDate` is omitted
  - `onDateChange` is now optional
  - `locale` is now optional (defaults to `"en-AU"`)
- `<FilterBar.DateRangePicker>` - extends <LinkTo pageId="components-filter-date-range-picker">FilterDateRangePicker</LinkTo>
  - `selectedRange` is omitted
  - `onRangeChange` is now optional
  - `locale` is now optional (defaults to `"en-AU"`)
- `<FilterBar.MultiSelect>` - extends <LinkTo pageId="components-filter-multi-select">FilterMultiSelect</LinkTo>
  - `selectedKeys` is omitted
  - `onSelectionChange` remains available as optional
  - **Note:** To use the subcomponents, import `FilterMultiSelect` from `@kaizen/components` (not `@kaizen/select`)
- `<FilterBar.Select>` - extends <LinkTo pageId="components-filter-select">FilterSelect</LinkTo>
  - `selectedKey` is omitted
  - `onSelectionChange` remains available as optional
  - **Note:** To use the subcomponents, import `FilterSelect` from `@kaizen/components` (not `@kaizen/select`)

##### `isRemovable?: boolean`

When this attribute is applied, the Filter will become removable (a remove button will be attached to the trigger button),
and its value will be cleared upon removal.

Filters with this attribute will be automatically put into the `Add Filter` menu on first render,
unless there is a default value provided, of which it will be in the active filters after the non-removable filters.

When removed from the active filters, the filter will be added to the `Add Filter` menu options.

##### `isUsableWhen?: (state: FiltersState<ValuesMap>) => boolean`

Note: _Usable_ refers to a filter showing in either the Active Filters or as an option in the Add Filters menu.

Use this attribute to apply a condition to a filter based on the state of another filter ([example here](#dependent-filters)).

The `state` arg will provide you with the following attributes for all the filters (mapped to the keys of the `ValuesMap`):
```ts
id: keyof ValuesMap
name: string
value?: ValueMap[keyof ValuesMap]
isActive: boolean
```

When a dependent filter has not met its condition (not _Usable_):
- it will be removed from the FilterBar
- if it has a value, the value will be cleared

If this attribute is not defined, the filter will default to be _Usable_.

### `values`

A key-value pair of currently active values.

The `values` prop should be in the shape of `{ [filterId]: filterValueType }` (matching `ValuesMap`).

This is instantiated by the consumer to allow for updates from external events (eg. using url params).

```tsx
type ValuesMap = {
  filterId1: string
  filterId2: number
}

// @note: Unless you are providing a default value for all the filters,
// you will want to wrap it in Partial.
const [values, setValues] = useState<Partial<ValuesMap>>({
  filterId1: "default-value"
})

return (
  <FilterBar<ValuesMap> values={values} {...rest} />
)
```

### `onValuesChange`

A callback (`(values: Partial<ValuesMap>) => void`) for when the active `values` change.

<NoClipCanvas of={FilterBarStories.OnValuesChange} />

## Examples

### Dependent filters

Example where `Topping` and `Drank` are usable only if `Flavour` has a value:

<NoClipCanvas of={FilterBarStories.DependentFilter} />

### Update values via external event

The api allows you to update the values of the FilterBar via an external event (eg. updating url params).

Simply update the value passed into the `values` prop.

Out of the box, we do not make assumptions about your state management tool, so you will need to encode/decode
the types to match the expected format of your chosen query param library.

The following example uses the
<a href="https://www.npmjs.com/package/serialize-query-params">serialize-query-params</a>
and <a href="https://www.npmjs.com/package/query-string">query-string</a>
packages.

<NoClipCanvas of={FilterBarStories.ExternalEventValuesUpdate} />
